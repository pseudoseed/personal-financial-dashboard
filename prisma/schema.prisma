generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model PlaidItem {
  id              String    @id @default(cuid())
  itemId          String    @unique
  accessToken     String
  refreshToken    String?
  provider        String    @default("plaid")
  institutionId   String
  institutionName String?
  institutionLogo String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  accounts        Account[]
}

model Account {
  id                         String                   @id @default(cuid())
  userId                     String                   @default("default")
  plaidId                    String                   @unique
  name                       String
  nickname                   String?
  type                       String
  subtype                    String?
  mask                       String?
  hidden                     Boolean                  @default(false)
  metadata                   String?
  url                        String?
  invertTransactions         Boolean                  @default(false)
  itemId                     String
  plaidSyncCursor            String?
  lastSyncTime               DateTime?
  lastStatementBalance       Float?
  minimumPaymentAmount       Float?
  nextPaymentDueDate         DateTime?
  lastPaymentDate            DateTime?
  lastPaymentAmount          Float?
  nextMonthlyPayment         Float?
  originationDate            DateTime?
  originationPrincipalAmount Float?
  createdAt                  DateTime                 @default(now())
  updatedAt                  DateTime                 @updatedAt
  user                       User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  plaidItem                  PlaidItem                @relation(fields: [itemId], references: [id], onDelete: Cascade)
  balances                   AccountBalance[]
  transactions               Transaction[]
  downloadLogs               TransactionDownloadLog[]
  recurringPayments          RecurringPayment[]
  emergencyFundAccounts      EmergencyFundAccount[]
}

model AccountBalance {
  id        String   @id @default(cuid())
  accountId String
  current   Float
  available Float?
  limit     Float?
  date      DateTime @default(now())
  account   Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([date])
}

model Transaction {
  id                      String                   @id @default(cuid())
  accountId               String
  plaidId                 String
  date                    DateTime
  name                    String
  amount                  Float
  category                String?
  merchantName            String?
  pending                 Boolean                  @default(false)
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  fees                    Float?
  isoCurrencyCode         String?
  price                   Float?
  quantity                Float?
  securityId              String?
  subtype                 String?
  tickerSymbol            String?
  type                    String?
  authorizedDate          DateTime?
  authorizedDatetime      DateTime?
  byOrderOf               String?
  closePrice              Float?
  closePriceAsOf          DateTime?
  cusip                   String?
  datetime                DateTime?
  industry                String?
  institutionSecurityId   String?
  isCashEquivalent        Boolean?
  isin                    String?
  locationAddress         String?
  locationCity            String?
  locationCountry         String?
  locationLat             Float?
  locationLon             Float?
  locationPostalCode      String?
  locationRegion          String?
  marketIdentifierCode    String?
  merchantEntityId        String?
  payee                   String?
  payer                   String?
  paymentChannel          String?
  paymentMethod           String?
  paymentProcessor        String?
  personalFinanceCategory String?
  ppd_id                  String?
  reason                  String?
  referenceNumber         String?
  sector                  String?
  securityName            String?
  securityType            String?
  sedol                   String?
  transactionCode         String?
  unofficialCurrencyCode  String?
  categoryAiGranular      String?
  categoryAiGeneral       String?
  categoryPlaidGranular   String?
  categoryPlaidGeneral    String?
  anomalies               AnomalyDetectionResult[]
  account                 Account                  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  recurringExpenseTransactions RecurringExpenseTransaction[]

  @@unique([accountId, plaidId])
  @@index([date])
}

model TransactionDownloadLog {
  id              String   @id @default(cuid())
  accountId       String
  startDate       DateTime
  endDate         DateTime
  numTransactions Int
  status          String
  errorMessage    String?
  createdAt       DateTime @default(now())
  account         Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([accountId, createdAt])
}

model User {
  id                     String                    @id @default(cuid())
  email                  String                    @unique
  name                   String?
  createdAt              DateTime                  @default(now())
  updatedAt              DateTime                  @updatedAt
  accounts               Account[]
  anomalySettings        AnomalyDetectionSettings?
  emailNotifications     EmailNotification[]
  dismissalRules         AnomalyDismissalRule[]
  recurringExpenses      RecurringExpense[]
  recurringPayments      RecurringPayment[]
  financialHealthMetrics FinancialHealthMetrics[]
  emergencyFundAccounts  EmergencyFundAccount[]

  @@map("users")
}

model AnomalyDetectionSettings {
  id                   String                   @id @default(cuid())
  userId               String                   @unique
  minAmount            Float                    @default(50)
  maxAmount            Float                    @default(10000)
  timeWindow           Int                      @default(30)
  zScoreThreshold      Float                    @default(2.5)
  newMerchantThreshold Float                    @default(100)
  geographicThreshold  Float                    @default(50)
  hoursWindow          Int                      @default(24)
  enabled              Boolean                  @default(true)
  emailNotifications   Boolean                  @default(true)
  emailFrequency       String                   @default("daily")
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt
  anomalies            AnomalyDetectionResult[]
  user                 User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AnomalyDetectionResult {
  id            String                   @id @default(cuid())
  settingsId    String
  transactionId String
  type          String
  severity      String
  reason        String
  metadata      Json?
  isResolved    Boolean                  @default(false)
  isHidden      Boolean                  @default(false)
  resolvedAt    DateTime?
  resolvedBy    String?
  createdAt     DateTime                 @default(now())
  transaction   Transaction              @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  settings      AnomalyDetectionSettings @relation(fields: [settingsId], references: [id], onDelete: Cascade)

  @@index([settingsId])
  @@index([transactionId])
  @@index([severity])
  @@index([isResolved])
  @@index([isHidden])
  @@index([createdAt])
}

model EmailNotification {
  id           String    @id @default(cuid())
  userId       String
  type         String
  subject      String
  content      String
  status       String    @default("pending")
  sentAt       DateTime?
  errorMessage String?
  metadata     Json?
  createdAt    DateTime  @default(now())
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model AnomalyDismissalRule {
  id          String   @id @default(cuid())
  userId      String
  ruleType    String   // 'merchant', 'category', 'amount_range'
  ruleValue   String   // JSON string containing rule criteria
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model RecurringExpense {
  id                    String                        @id @default(cuid())
  userId                String                        @default("default")
  name                  String                        // Human-readable name (e.g., "Netflix Subscription")
  merchantName          String                        // Original merchant name from transactions
  category              String?                       // Transaction category
  amount                Float                         // Expected amount
  frequency             String                        // 'monthly', 'weekly', 'quarterly', 'yearly'
  nextDueDate           DateTime?                     // When the next payment is expected
  lastTransactionDate   DateTime                      // Date of last occurrence
  confidence            Int                           // Detection confidence score (0-100)
  isActive              Boolean                       @default(true)
  isConfirmed           Boolean                       @default(false)
  createdAt             DateTime                      @default(now())
  updatedAt             DateTime                      @updatedAt
  user                  User                          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions          RecurringExpenseTransaction[]

  @@index([userId])
  @@index([merchantName])
  @@index([isActive])
  @@index([isConfirmed])
}

model RecurringExpenseTransaction {
  id                  String           @id @default(cuid())
  recurringExpenseId  String
  transactionId       String
  createdAt           DateTime         @default(now())
  recurringExpense    RecurringExpense @relation(fields: [recurringExpenseId], references: [id], onDelete: Cascade)
  transaction         Transaction      @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@unique([recurringExpenseId, transactionId])
  @@index([recurringExpenseId])
  @@index([transactionId])
}

model RecurringPayment {
  id                    String                        @id @default(cuid())
  userId                String                        @default("default")
  name                  String                        // Human-readable name (e.g., "Bi-weekly Paycheck")
  amount                Float                         // Expected payment amount
  frequency             String                        // 'weekly', 'bi-weekly', 'monthly', 'quarterly', 'yearly'
  nextPaymentDate       DateTime                      // When the next payment is expected
  lastPaymentDate       DateTime?                     // Date of last occurrence (optional for new payments)
  dayOfWeek             Int?                          // Day of week (0-6, Sunday=0) for weekly/bi-weekly
  dayOfMonth            Int?                          // Day of month (1-31) for monthly payments
  paymentType           String                        // 'direct_deposit', 'paycheck', 'investment_dividend', 'other'
  targetAccountId       String?                       // Account where payment is deposited
  isActive              Boolean                       @default(true)
  isConfirmed           Boolean                       @default(false)
  confidence            Int                           // Detection confidence score (0-100)
  createdAt             DateTime                      @default(now())
  updatedAt             DateTime                      @updatedAt
  user                  User                          @relation(fields: [userId], references: [id], onDelete: Cascade)
  targetAccount         Account?                      @relation(fields: [targetAccountId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([isActive])
  @@index([isConfirmed])
  @@index([nextPaymentDate])
  @@index([targetAccountId])
}

model FinancialHealthMetrics {
  id                   String   @id @default(cuid())
  userId               String
  overallScore         Int      // 0-100 score
  emergencyFundRatio   Float?   // Months of expenses covered
  debtToIncomeRatio    Float?   // Total debt / monthly income
  savingsRate          Float?   // Monthly savings / monthly income
  creditUtilization    Float?   // Credit used / total credit limit
  calculatedAt         DateTime @default(now())
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([calculatedAt])
}

model EmergencyFundAccount {
  id        String  @id @default(cuid())
  userId    String
  accountId String
  user      User    @relation(fields: [userId], references: [id])
  account   Account @relation(fields: [accountId], references: [id])
  @@unique([userId, accountId])
}
